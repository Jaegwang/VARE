//----------//
// main.cpp //
//-------------------------------------------------------//
// author: Jaegwang Lim @ Dexter Studios                 //
// last update: 2016.10.10                               //
//-------------------------------------------------------//

#include <ri.h>
#include <Bora.h>
#include <openvdb/openvdb.h>
#include <openvdb/tools/ChangeBackground.h>
#include <openvdb/tools/LevelSetSphere.h>
#include <openvdb/tools/Interpolation.h>
#include <openvdb/tools/VolumeToMesh.h>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>

float radius;
float voxelSize;
int   frame;

std::string file;
std::string VDBFilePath0;
std::string VDBFilePath1;
std::string name;

extern "C"
{
	PRMANEXPORT RtPointer ConvertParameters ( RtString paramStr              );
	PRMANEXPORT RtVoid    Subdivide         ( RtPointer data, RtFloat detail );
	PRMANEXPORT RtVoid    Free              ( RtPointer data                 );
}

RtPointer ConvertParameters( RtString paramStr )
{
	// JSON Parsing.
	std::string str = paramStr;
	std::stringstream ss;
	ss << str;
	
	boost::property_tree::ptree pt;
	boost::property_tree::read_json(ss, pt);

	file = pt.get<std::string>("file");
	VDBFilePath0 = pt.get<std::string>("vdb");
	name = pt.get<std::string>("name");

	frame = pt.get<int>("frame");
	voxelSize = pt.get<float>("voxelSize");
	radius = pt.get<float>("radius");
	

//	openvdb::FloatGrid::Ptr grid = openvdb::tools::createLevelSetSphere< openvdb::FloatGrid >
//		( radius, /*center*/openvdb::Vec3f(0.f,0.f,0.f), /*voxel size*/0.1, /*width*/3.0 );

	return static_cast<RtPointer>(0);
}

RtVoid Subdivide( RtPointer data, RtFloat detail )
{
	// Write VDB
	openvdb::initialize();

	Vec3fArray points;
	Vec3fArray vels;
	ImportBgeoPointAttribV3( file.c_str(), "P", points );
	ImportBgeoPointAttribV3( file.c_str(), "v", vels );

//	points.initialize( 1 );
//	points[0] = Vec3f( 0.f, 0.f, 0.f );

	openvdb::FloatGrid::Ptr grid;

	Volumizer volumeizer;
	volumeizer.scale = 1.f;

	volumeizer.VDBFromPointCloud( grid, points, radius, voxelSize );
	
	grid->setName( name );
		
	openvdb::GridPtrVec grids;
	grids.push_back( grid );
		
	openvdb::io::File file( VDBFilePath0 );
		
	file.write( grids );
	file.close();

	openvdb::CoordBBox bbox = grid->evalActiveVoxelBoundingBox();

	std::cout<< VDBFilePath0 << std::endl;

	/*
	{
		for( int i=0; i<points.num(); ++i )
		{
			points[i] += vels[i] * (1.f/24.f);
		}

		openvdb::FloatGrid::Ptr grid1;
		volumeizer.VDBFromPointCloud2( grid1, points, radius, voxelSize );

		grid1->setName( name );

		openvdb::GridPtrVec grids;
		grids.push_back( grid1 );

		VDBFilePath1 = VDBFilePath0;
		VDBFilePath1.append("_1");

		openvdb::io::File file1( VDBFilePath1 );

		file1.write( grids );
		file1.close();

		openvdb::CoordBBox bbox1 = grid1->evalActiveVoxelBoundingBox();
		bbox.expand( bbox1 );
	}
	*/
	
	// Render VDB
	{
		RiAttributeBegin();
		RiTransformBegin();

		openvdb::Coord min = bbox.min();
		openvdb::Coord max = bbox.max();

		openvdb::Vec3f minPos( min.x(), min.y(), min.z() );
		openvdb::Vec3f maxPos( max.x(), max.y(), max.z() );

		minPos = grid->indexToWorld( minPos );
		maxPos = grid->indexToWorld( maxPos );

		RtBound bound = { minPos.x(), maxPos.x(), 
			              minPos.y(), maxPos.y(), 
						  minPos.z(), maxPos.z() };
						  
		int dims[3] = { 0,0,0 };

		RtToken nms[4] = {
			"constant string[2] blobbydso:stringargs",
			"varying float density",
			"varying float temperature",
			"constant float blobbydso:threshold"		
		};

		char* p0[2] = {
			(char*)VDBFilePath0.c_str(),
			"density"
		};

		char* pp0[2] = {
			(char*)VDBFilePath1.c_str(),
			"density"
		};		

		void* p1 = 0;
		void* p2 = 0;		

		float p3[1] = { 0.0 };

		RtPointer vals0[4] = {
			(void*)p0,
			p1,
			p2,
			(void*)p3
		};

		RtPointer vals1[4] = {
			(void*)pp0,
			p1,
			p2,
			(void*)p3
		};		

		//float motions[2] = { 0.5f, 0.5f };
		//RiMotionBeginV( 1, motions );

		RiVolumeV( "blobbydso:impl_openvdb", bound, dims, 4, nms, vals0 );
		//RiVolumeV( "blobbydso:impl_openvdb", bound, dims, 4, nms, vals1 );

		//RiMotionEnd();

		RiTransformEnd();
		RiAttributeEnd();
	}
}

RtVoid Free( RtPointer data )
{
}

